# SOLID Principles With Example:
![Javascript](https://img.shields.io/badge/node.js-6DA55F?style=for-the-badge&logo=node.js&logoColor=white)

- Single responsibility priciple (SRP)
- Open/Closed principle (OCP)
- Liskov substitution principe (LSP)
- Interface segregation principle (ISP)
- Dependency inversion principle (DIP)
## SOLID
`SOLID` is an acronym for a set of design principles created for developing software using object-oriented languages.

The SOLID principles are designed to encourage the creation of code that is simpler, more dependable, and easier to enhance. Each letter in SOLID stands for one design principle.

When implemented correctly, this makes your code more extensible, logical, maintainable, and easier to read.

To understand SOLID principles, you must have a good understanding of how interfaces are used.

### 1. Single Responsibility Principle
`The Single Responsibility Principle (SRP) is a design principle that states that a class or module should have only one reason to change. In other words, a class or module should have only one responsibility, and that responsibility should be encapsulated within that class or module.`

### 2. Open-Closed Principle
`The Open-Closed Principle (OCP) is a design principle that states that software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. In other words, we should be able to add new functionality to a system without changing its existing code.`

### 3. Liskov Substitution Principle
`The Liskov Substitution Principle (LSP) is a design principle that states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. In other words, a subclass should be able to replace its superclass in any context without changing the behavior of the program.`


### 4. Interface Segregation Principle
`The Interface Segregation Principle (ISP) is a design principle that states that no client should be forced to depend on methods it does not use. In other words, a class should not have to implement methods that it does not need, just because those methods are part of an interface. This principle helps to keep interfaces small and focused, making them easier to implement and maintain.`

### 5. Dependency Inversion Principle
`The Dependency Inversion Principle (DIP) is a design principle that states that high-level modules should not depend on low-level modules, but both should depend on abstractions. In other words, we should depend on abstractions rather than concrete implementations.`